/* ligand/find-waters.cc
 * 
 * Copyright 2004, 2005, 2006, 2007 The University of York
 * Copyright 2008 by The University of Oxford
 * Author: Paul Emsley
  * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc.,  59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */


#include <algorithm> // for sorting.
#include <queue>

// #include "clipper/ccp4/ccp4_map_io.h"
#include "clipper/ccp4/ccp4_mtz_io.h"
#include "clipper/core/map_interp.h"
#include "clipper/core/hkl_compute.h"
#include "clipper/contrib/skeleton.h"
#include "clipper/mmdb/clipper_mmdb.h"

#include "utils/coot-utils.hh"
#include "coot-map-utils.hh"


bool
coot::util::map_fill_from_mtz(clipper::Xmap<float> *xmap,
			      std::string mtz_file_name,
			      std::string f_col,
			      std::string phi_col,
			      std::string weight_col,
			      short int use_weights,
			      short int is_diff_map) {

   return coot::util::map_fill_from_mtz(xmap, mtz_file_name, f_col, phi_col, weight_col,
				 use_weights, is_diff_map, 0, 0);
}

bool
coot::util::map_fill_from_mtz(clipper::Xmap<float> *xmap,
			      std::string mtz_file_name,
			      std::string f_col,
			      std::string phi_col,
			      std::string weight_col,
			      short int use_weights,
			      short int is_diff_map,
			      float reso_limit_high,
			      short int use_reso_limit_high) {

  if (!file_exists(mtz_file_name))
      return 0;

  clipper::HKL_info myhkl; 
  clipper::MTZdataset myset; 
  clipper::MTZcrystal myxtl; 

  std::cout << "reading mtz file..." << std::endl; 
  clipper::CCP4MTZfile mtzin; 
  mtzin.open_read( mtz_file_name );       // open new file 
  mtzin.import_hkl_info( myhkl );         // read sg, cell, reso, hkls
  clipper::HKL_data< clipper::datatypes::F_sigF<float> >   f_sigf_data(myhkl, myxtl);
  clipper::HKL_data< clipper::datatypes::Phi_fom<float> > phi_fom_data(myhkl, myxtl);
  clipper::HKL_data< clipper::datatypes::F_phi<float> >       fphidata(myhkl, myxtl); 


  if ( use_weights ) {
     clipper::String dataname = "/*/*/[" + f_col + " " + f_col + "]";
     std::cout << dataname << "\n";
     mtzin.import_hkl_data(  f_sigf_data, myset, myxtl, dataname ); 
     dataname = "/*/*/[" + phi_col + " " + weight_col + "]";
     std::cout << dataname << "\n";
     mtzin.import_hkl_data( phi_fom_data, myset, myxtl, dataname );
     mtzin.close_read(); 
     std::cout << "We should use the weights: " << weight_col << std::endl;

     fphidata.compute(f_sigf_data, phi_fom_data,
		      clipper::datatypes::Compute_fphi_from_fsigf_phifom<float>());
     
  } else {
     clipper::String dataname = "/*/*/[" + f_col + " " + phi_col + "]";
     mtzin.import_hkl_data(     fphidata, myset, myxtl, dataname );
     mtzin.close_read(); 
  }
  std::cout << "Number of reflections: " << myhkl.num_reflections() << "\n"; 
  std::cout << "finding ASU unique map points..." << std::endl;

  clipper::Resolution fft_reso;
  if (use_reso_limit_high) {
     clipper::Resolution user_resolution(reso_limit_high);
     fft_reso = user_resolution;
     coot::util::filter_by_resolution(&fphidata, 99999.0, reso_limit_high);
  } else {
     fft_reso = clipper::Resolution(1.0/sqrt(fphidata.invresolsq_range().max()));
  }
  
  xmap->init( myhkl.spacegroup(), myhkl.cell(),
	      clipper::Grid_sampling( myhkl.spacegroup(),
				      myhkl.cell(),
				      fft_reso));
  std::cout << "Grid..." << xmap->grid_sampling().format() << "\n";
  std::cout << "doing fft..." << std::endl;
  xmap->fft_from( fphidata );                  // generate map
  std::cout << "done fft..." << std::endl;
  return 1;
}

// Return a map that is a copy of the given map with interpolation,
// with grid spacing at most 0.5A (by generated by integer scaling
// factor of the input map)
// 
clipper::Xmap<float>
coot::util::reinterp_map_fine_gridding(const clipper::Xmap<float> &xmap) {

   float cell_length[3];
   cell_length[0] = xmap.cell().descr().a();
   cell_length[1] = xmap.cell().descr().b();
   cell_length[2] = xmap.cell().descr().c();

   int sampling[3];
   sampling[0] = xmap.grid_sampling().nu();
   sampling[1] = xmap.grid_sampling().nv();
   sampling[2] = xmap.grid_sampling().nw();

   float rate[3];
   for (int i=0; i<3; i++)
      rate[i] = float(sampling[i])/(cell_length[i] + 0.0001);
   float smallest_rate = 100000;
   for (int i=0; i<3; i++)
      if (rate[i] < smallest_rate)
	 smallest_rate = rate[i];
   // so now we have smallest_rate;

   // what do we need to multiply smallest_rate by to get a number
   // better than 2?
   int multiplier = 1;
   int count = 1000;
   for (int icount = 0; icount<count; icount++) { 
      if (smallest_rate * float(multiplier) > 2.0)
	 break;
      multiplier += 1;
   }
   // so now we have multiplier

   if (multiplier == 1) {
      return xmap; // the input map
   } else {

      clipper::Grid_sampling gs_old = xmap.grid_sampling();
      clipper::Grid_sampling gs(sampling[0]*multiplier,
				sampling[1]*multiplier,
				sampling[2]*multiplier);
   
      clipper::Xmap<float> xmap_new(xmap.spacegroup(), xmap.cell(), gs);

      float dv;
      clipper::Xmap_base::Map_reference_index ix;
      for (ix = xmap_new.first(); !ix.last(); ix.next() )  { // iterator index.
	 clipper::Coord_grid cg = ix.coord();
	 clipper::Coord_frac cf = cg.coord_frac(gs);
	 clipper::Coord_grid cg_old = cf.coord_grid(gs_old);
	 dv = xmap.interp<clipper::Interp_cubic>(cf);
	 xmap_new[ix] = dv;
      }
      return xmap_new;
   }
}

// Note density_at_point in molecule-class-info looks as if its
// returning grid values, not interpollated values.  Is that bad?
//
float
coot::util::density_at_point(const clipper::Xmap<float> &xmap,
			     const clipper::Coord_orth &pos) {

   float dv;
   clipper::Coord_frac a_cf = pos.coord_frac(xmap.cell());
   clipper::Coord_map  a_cm = a_cf.coord_map(xmap.grid_sampling());
   clipper::Interp_cubic::interp(xmap, a_cm, dv);
   return dv;
}

void
coot::util::filter_by_resolution(clipper::HKL_data< clipper::datatypes::F_phi<float> > *fphidata,
				 const float &reso_low,
				 const float &reso_high) {

   float inv_low  = 1.0/(reso_low*reso_low);
   float inv_high = 1.0/(reso_high*reso_high);
   int n_data = 0;
   int n_reset = 0;
      
   for (clipper::HKL_info::HKL_reference_index hri = fphidata->first(); !hri.last(); hri.next()) {
      n_data++;

      if ( hri.invresolsq() > inv_low &&
	   hri.invresolsq() < inv_high) {
      } else {
	 (*fphidata)[hri].f() = 0.0;
	 n_reset++;
      } 
   }
}


float
coot::util::density_at_map_point(const clipper::Xmap<float> &xmap,
				 const clipper::Coord_map   &cm) {

   float dv;
   clipper::Interp_cubic::interp(xmap, cm, dv);
   return dv;
}

coot::util::density_stats_info_t
coot::util::density_around_point(const clipper::Coord_orth &point,
				 const clipper::Xmap<float> &xmap,
				 float d) {

   coot::util::density_stats_info_t s;
   // what are the points?
   // +/- d along the x, y and z axes
   // and 2x4 samples at 45 degrees inclination and 45 degree longitudinal rotation.
   //
   std::vector<clipper::Coord_orth> sample_points(14);

   sample_points[0] = clipper::Coord_orth( 0.0,  0.0,  1.0);
   sample_points[1] = clipper::Coord_orth( 0.0,  0.0, -1.0);
   sample_points[2] = clipper::Coord_orth( 0.0,  1.0,  0.0);
   sample_points[3] = clipper::Coord_orth( 0.0, -1.0,  0.0);
   sample_points[4] = clipper::Coord_orth(-1.0,  0.0,  0.0);
   sample_points[5] = clipper::Coord_orth( 1.0,  0.0,  0.0);

   sample_points[6] = clipper::Coord_orth( 0.5,  0.5,  0.7071);
   sample_points[7] = clipper::Coord_orth(-0.5,  0.5,  0.7071);
   sample_points[8] = clipper::Coord_orth(-0.5, -0.5,  0.7071);
   sample_points[9] = clipper::Coord_orth( 0.5, -0.5,  0.7071);

   sample_points[10] = clipper::Coord_orth( 0.5,  0.5, -0.7071);
   sample_points[11] = clipper::Coord_orth(-0.5,  0.5, -0.7071);
   sample_points[12] = clipper::Coord_orth(-0.5, -0.5, -0.7071);
   sample_points[13] = clipper::Coord_orth( 0.5, -0.5, -0.7071);

   float dv;
   for (float scale = 0.2; (scale-0.0001)<=1.0; scale += 0.4) { 
      for (int i=0; i<14; i++) {
	 dv = density_at_point(xmap, point + d*scale*sample_points[i]);
	 s.add(dv, scale); // scale is the weight, which multiplies
			   // additions internally.
      }
   } 
   
   return s;
}


float
coot::util::map_score(PPCAtom atom_selection,
		      int n_selected_atoms,
		      const clipper::Xmap<float> &xmap,
		      short int with_atomic_weighting) {

   // Thanks Ezra.

   float f = 0.0;
   float f1;

   for (int i=0; i<n_selected_atoms; i++) {
      f1 = density_at_point(xmap, clipper::Coord_orth(atom_selection[i]->x,
						      atom_selection[i]->y,
						      atom_selection[i]->z));
      f1 *= atom_selection[i]->occupancy;
      f += f1;
   }
   return f;
}

float coot::util::map_score_atom(CAtom *atom,
				 const clipper::Xmap<float> &xmap) {

   float f = 0;
   if (atom) { 
      f = density_at_point(xmap, clipper::Coord_orth(atom->x, atom->y, atom->z));
   }
   return f;
}



// A/grid
// 
float
coot::util::max_gridding(const clipper::Xmap<float> &xmap) {

   float a_gridding = xmap.cell().a()/xmap.grid_sampling().nu(); 
   float b_gridding = xmap.cell().b()/xmap.grid_sampling().nv(); 
   float c_gridding = xmap.cell().c()/xmap.grid_sampling().nw(); 

   float gridding_max = 0; 
   
   if ( a_gridding > gridding_max) 
      gridding_max = a_gridding; 
   if ( b_gridding > gridding_max) 
      gridding_max = b_gridding; 
   if ( c_gridding > gridding_max) 
      gridding_max = c_gridding; 

   return gridding_max; 
}

clipper::RTop_orth
coot::util::make_rtop_orth_from(mat44 mat) {

   clipper::Mat33<double> clipper_mat(mat[0][0], mat[0][1], mat[0][2],
				      mat[1][0], mat[1][1], mat[1][2],
				      mat[2][0], mat[2][1], mat[2][2]);
   clipper::Coord_orth  cco(mat[0][3], mat[1][3], mat[2][3]);
   clipper::RTop_orth rtop(clipper_mat, cco);
   
   return rtop;
}

clipper::Xmap<float>
coot::util::sharpen_map(const clipper::Xmap<float> &xmap_in, float sharpen_factor) {

   clipper::HKL_info myhkl; 
   clipper::HKL_data< clipper::datatypes::F_phi<float> >       fphidata(myhkl); 

   xmap_in.fft_to(fphidata);

//    for (clipper::HKL_info::HKL_reference_index hri = fphidata->first(); !hri.last(); hri.next()) {
//       float reso = hri.invresolsq();
//       std::cout << hri.format() << " has reso " << reso << std::endl;
//       float fac = 1.0;
      
//       (*fphidata)[hri].f() = fac;
//    }

   clipper::Xmap<float> r;
   r.fft_from(fphidata);
   return r;
}


clipper::Xmap<float>
coot::util::transform_map(const clipper::Xmap<float> &xmap_in,
			  const clipper::Spacegroup &new_space_group,
			  const clipper::Cell &new_cell,
			  const clipper::RTop_orth &rtop,
			  const clipper::Coord_orth &to_pt,
			  float box_size) {

   // we now need to create about_pt: i.e. where the map is pulled *from*
   clipper::Coord_orth about_pt = to_pt.transform(rtop.inverse());

   clipper::Xmap<float> xmap;
   clipper::Grid_sampling new_gs = coot::util::suggested_grid_sampling(xmap_in.grid_sampling(),
								       xmap_in.cell(),
								       new_space_group,
								       new_cell);

   std::cout << "INFO:: creating new map for transformed map with spacegroup: " << new_space_group.symbol_hm()
	     << " cell: " << new_cell.format() << " grid-sampling " << new_gs.format()
	     << std::endl;
   
   xmap.init(new_space_group, new_cell, new_gs);

   std::cout << "coord info:         to_pt: " << to_pt.format()    << std::endl;
   std::cout << "coord info:      about_pt: " << about_pt.format() << std::endl;
   
   clipper::Grid_sampling grid = xmap.grid_sampling();
   clipper::Grid_range gr(xmap.cell(), xmap.grid_sampling(), box_size);
   clipper::Coord_grid g, g0, g1;
   clipper::RTop_orth rtop_inv = rtop.inverse();
   typedef clipper::Xmap<float>::Map_reference_coord MRC;
   MRC i0, iu, iv, iw;
   g = to_pt.coord_frac(new_cell).coord_grid(new_gs);

   std::cout << "DEBUG:: pulling map from point:   " << about_pt.format() << std::endl;
   std::cout << "DEBUG:: creating map about point: " << to_pt.format() << std::endl;

   std::cout << "DEBUG:: grid point g: " << g.format() << std::endl;
   std::cout << "DEBUG:: grid range gr: " << gr.format() << std::endl;
   std::cout << "DEBUG:: grid range gr.min: " << gr.min().format() << std::endl;
   std::cout << "DEBUG:: grid range gr.max: " << gr.max().format() << std::endl;

   std::vector<coot::util::map_ref_triple_t> density_points;

   g0 = g + gr.min();
   g1 = g + gr.max();
   i0 = MRC( xmap, g0 );

   clipper::Coord_orth iw_pos;
   clipper::Coord_orth dpt;
   double d2;
   
   for ( iu = i0; iu.coord().u() <= g1.u(); iu.next_u() )
      for ( iv = iu; iv.coord().v() <= g1.v(); iv.next_v() )
         for ( iw = iv; iw.coord().w() <= g1.w(); iw.next_w() ) {
	    iw_pos = iw.coord().coord_frac(grid).coord_orth(xmap.cell());
            dpt =    iw_pos.transform(rtop_inv);
            d2 = (iw_pos - to_pt).lengthsq();
            density_points.push_back(coot::util::map_ref_triple_t(d2, iw, coot::util::density_at_point(xmap_in, dpt)));
         }
   std::sort(density_points.begin(), density_points.end());
   for (unsigned int ic=0; ic<density_points.size(); ic++)
      xmap[density_points[ic].iw] = density_points[ic].density;

   return xmap;
}


clipper::Grid_sampling
coot::util::suggested_grid_sampling(const clipper::Grid_sampling &orig_sampling,
				    const clipper::Cell &orig_cell,
				    const clipper::Spacegroup &new_space_group,
				    const clipper::Cell &new_cell) {

   float sampling_a = orig_cell.a()/float(orig_sampling.nu());
   float sampling_b = orig_cell.b()/float(orig_sampling.nv());
   float sampling_c = orig_cell.c()/float(orig_sampling.nw());

   float best_sampling = sampling_a;
   if (sampling_b < best_sampling)
      best_sampling = sampling_b;
   if (sampling_c < best_sampling)
      best_sampling = sampling_c;

   clipper::Resolution resolution(best_sampling * 3.0);

   return clipper::Grid_sampling(new_space_group, new_cell, resolution, 2.0);
} 



std::pair<float, float>
coot::util::mean_and_variance(const clipper::Xmap<float> &xmap) {

   clipper::Xmap_base::Map_reference_index ix;
   double sum = 0.0;
   double sum_sq = 0.0;
   int npoints = 0;
   float d;
   for (ix = xmap.first(); !ix.last(); ix.next() ) {
      npoints++;
      d = xmap[ix];
      sum += d;
      sum_sq += d*d;
   }
   double mean = 0.0;
   double var = -1.0; 

   if (npoints > 0) { 
      mean = sum/float(npoints);
      var = sum_sq/float(npoints) - mean*mean;
   }

   return std::pair<float, float> (mean, var);
}


clipper::Xmap<float>
coot::util::laplacian_transform(const clipper::Xmap<float> &xmap_in) {

   clipper::Xmap<float> laplacian = xmap_in;

   clipper::Coord_map pos;
   float val;
   clipper::Grad_map<float> grad;
   clipper::Curv_map<float> curv;
   
   clipper::Xmap_base::Map_reference_index ix;
   for (ix = xmap_in.first(); !ix.last(); ix.next())  {
      // xmap_in.interp_curv(pos, val, grad, curv);
      clipper::Interp_cubic::interp_curv(xmap_in, ix.coord().coord_map(), val, grad, curv);
      val = curv.det();
      laplacian[ix] = -val;
   }
   
   return laplacian;
}

// Spin the torsioned atom round the rotatable bond and find the
// orientation (in degrees) that is in the highest density.
// 
// return a torsion.  Return -1111 (less than -1000) on failure
float
coot::util::spin_search(const clipper::Xmap<float> &xmap, CResidue *res, coot::torsion tors) {

   // The plan:
   //
   // 1) find 4 atoms in residue that correspond to the torsion
   //
   // 2) Use rotate point about vector to generate new points
   //
   //      Test density at new points

   float best_ori = -1111.1; //returned thing
   
   std::vector<CAtom * > match_atoms = tors.matching_atoms(res);

   if (match_atoms.size() != 4) { 
      std::cout << "ERROR:: not all atoms for torsion found in residue!" << std::endl;
      std::cout << "        (found " << match_atoms.size() << " atoms.)" << std::endl;
   } else {

      clipper::Coord_orth pa1(match_atoms[0]->x, match_atoms[0]->y, match_atoms[0]->z);
      clipper::Coord_orth pa2(match_atoms[1]->x, match_atoms[1]->y, match_atoms[1]->z); 
      clipper::Coord_orth pa3(match_atoms[2]->x, match_atoms[2]->y, match_atoms[2]->z);
      clipper::Coord_orth pa4(match_atoms[3]->x, match_atoms[3]->y, match_atoms[3]->z);

      float best_d = -99999999.9;
      for (double theta=0; theta <=360; theta+=3.0) {

	 clipper::Coord_orth dir   = pa3 - pa2;
	 clipper::Coord_orth pos   = pa4;
	 clipper::Coord_orth shift = pa3;
	 clipper::Coord_orth co = coot::util::rotate_round_vector(dir, pos, shift, theta);
	 float this_d = coot::util::density_at_point(xmap, co);
	 if (this_d > best_d) {
	    best_d = this_d;
	    best_ori = theta;
// 	    std::cout << "better density " <<  best_d << " at "
// 		      << co.format() << " " << best_ori << std::endl;
	 }
      }
   }
   // std::cout << "returning " << best_ori << std::endl;
   return best_ori;
}

// return a map and its standard deviation.  scale is applied to
// map_in_2 before substraction.
std::pair<clipper::Xmap<float>, float>
coot::util::difference_map(const clipper::Xmap<float> &xmap_in_1,
			   const clipper::Xmap<float> &xmap_in_2,
			   float map_scale) {
   clipper::Xmap<float> r = xmap_in_1;
   float std_dev = 0.2;

    clipper::Xmap_base::Map_reference_index ix;
    for (ix = r.first(); !ix.last(); ix.next())  {
       clipper::Coord_map  cm1 = ix.coord().coord_map();
       clipper::Coord_frac cf1 = cm1.coord_frac(xmap_in_1.grid_sampling());
       clipper::Coord_orth co  = cf1.coord_orth(xmap_in_1.cell());
       clipper::Coord_frac cf2 =  co.coord_frac(xmap_in_2.cell());
       clipper::Coord_map  cm2 = cf2.coord_map(xmap_in_2.grid_sampling());
       float map_2_val;
       clipper::Interp_cubic::interp(xmap_in_2, cm2, map_2_val);
       r[ix] = xmap_in_1[ix] - map_scale * map_2_val;
    }
   return std::pair<clipper::Xmap<float>, float> (r, std_dev); 
}

// make a copy of map_in, but in the cell and gridding of reference_map
clipper::Xmap<float>
coot::util::reinterp_map(const clipper::Xmap<float> &xmap_in,
			 const clipper::Xmap<float> &reference_xmap) {

   clipper::Xmap<float> rmap;
   rmap.init(reference_xmap.spacegroup(), reference_xmap.cell(), reference_xmap.grid_sampling());
   clipper::Xmap_base::Map_reference_index ix;
   for (ix = rmap.first(); !ix.last(); ix.next())  {
      clipper::Coord_map  cm1 = ix.coord().coord_map();
      clipper::Coord_frac cf1 = cm1.coord_frac(rmap.grid_sampling());
      clipper::Coord_orth co  = cf1.coord_orth(rmap.cell());
      clipper::Coord_frac cf2 =  co.coord_frac(xmap_in.cell());
      clipper::Coord_map  cm2 = cf2.coord_map( xmap_in.grid_sampling());
      float map_2_val;
      clipper::Interp_cubic::interp(xmap_in, cm2, map_2_val);
      rmap[ix] = map_2_val;
   }
   return rmap;

} 


clipper::Xmap<float>
coot::util::average_map(const std::vector<std::pair<clipper::Xmap<float>, float> > &maps_and_scales_vec) {
   
   clipper::Xmap<float> rmap;

   if (maps_and_scales_vec.size() > 0) {

      for (unsigned int imap=0; imap<maps_and_scales_vec.size(); imap++) 
	 std::cout << "INFO:: multiplying map (function index) " << imap << " " 
		   << maps_and_scales_vec[imap].first.grid_sampling().format()
		   << " by " << maps_and_scales_vec[imap].second << std::endl;

	  
      // set the first map and scale it.
      rmap = maps_and_scales_vec[0].first;
      clipper::Xmap_base::Map_reference_index ix;
      for (ix = rmap.first(); !ix.last(); ix.next())
	 rmap[ix] *= maps_and_scales_vec[0].second;

      for (unsigned int iothers=1; iothers<maps_and_scales_vec.size(); iothers++) {
	 for (ix = rmap.first(); !ix.last(); ix.next())  {
	    clipper::Coord_map  cm1 = ix.coord().coord_map();
	    clipper::Coord_frac cf1 = cm1.coord_frac(rmap.grid_sampling());
	    clipper::Coord_orth co  = cf1.coord_orth(rmap.cell());
	    clipper::Coord_frac cf2 =  co.coord_frac(maps_and_scales_vec[iothers].first.cell());
	    clipper::Coord_map  cm2 = cf2.coord_map(maps_and_scales_vec[iothers].first.grid_sampling());
	    float map_2_val;
	    clipper::Interp_cubic::interp(maps_and_scales_vec[iothers].first, cm2, map_2_val);
	    rmap[ix] += map_2_val * maps_and_scales_vec[iothers].second;
	 }
      }
      float scale_sum = 0.0;
      for (unsigned int i=0; i<maps_and_scales_vec.size(); i++) {
	 scale_sum += maps_and_scales_vec[i].second;
      }
      if (scale_sum != 0.0) { 
	 float sf = 1.0/scale_sum;
	 for (ix = rmap.first(); !ix.last(); ix.next())  {
	    rmap[ix] *= sf;
	 }
      }
   }
   return rmap;
}

// like above, but variance, scales are ignored.
// 
clipper::Xmap<float>
coot::util::variance_map(const std::vector<std::pair<clipper::Xmap<float>, float> > &maps_and_scales_vec) {

   clipper::Xmap<float> rmap;
   clipper::Xmap<float> sum_map;
   clipper::Xmap<float> sum_squares_map;
   if (maps_and_scales_vec.size()) {
      // set the first map
      int n_maps = maps_and_scales_vec.size();
      const clipper::Xmap<float> &first_map = maps_and_scales_vec[0].first;
      sum_map = first_map;
      sum_squares_map.init(first_map.spacegroup(), first_map.cell(), first_map.grid_sampling());
      rmap.init(           first_map.spacegroup(), first_map.cell(), first_map.grid_sampling());
      clipper::Xmap_base::Map_reference_index ix;
      for (ix = sum_map.first(); !ix.last(); ix.next())  {
	 sum_squares_map[ix] = sum_map[ix] * sum_map[ix];
      }
      for (unsigned int iothers=1; iothers<maps_and_scales_vec.size(); iothers++) {
	 for (ix = sum_map.first(); !ix.last(); ix.next())  {
	    clipper::Coord_map  cm1 = ix.coord().coord_map();
	    clipper::Coord_frac cf1 = cm1.coord_frac(sum_map.grid_sampling());
	    clipper::Coord_orth co  = cf1.coord_orth(sum_map.cell());
	    clipper::Coord_frac cf2 =  co.coord_frac(maps_and_scales_vec[iothers].first.cell());
	    clipper::Coord_map  cm2 = cf2.coord_map(maps_and_scales_vec[iothers].first.grid_sampling());
	    float map_2_val;
	    clipper::Interp_cubic::interp(maps_and_scales_vec[iothers].first, cm2, map_2_val);
	    float v = map_2_val;
	    sum_map[ix] += v;
	    sum_squares_map[ix] += v * v;
	 }
      }
      float f = 1.0/float(n_maps);
      for (ix = rmap.first(); !ix.last(); ix.next()) {
	 float mean = sum_map[ix] * f;
	 rmap[ix] = sum_squares_map[ix] * f  - mean*mean;
      }
   }
   return rmap;
}



// Delete atoms that don't have this alt conf (or "" alt conf).
void
coot::util::backrub_residue_triple_t::trim_this_residue_atoms() {

   std::vector<std::string> vec;
   trim_residue_atoms_generic(this_residue, vec, 0);
}

void
coot::util::backrub_residue_triple_t::trim_residue_atoms_generic(CResidue *residue_p,
								 std::vector<std::string> keep_atom_vector,
								 bool use_keep_atom_vector) {

   // Hmmm... in other places, I don't go round the houses (make the
   // vector, then delete).  I just DeleteAtom(), so it may not be
   // necessary here.
   
   if (residue_p) {
      std::vector<int> delete_atom_index_vec;
      PPCAtom residue_atoms;
      int n_residue_atoms;
      residue_p->GetAtomTable(residue_atoms, n_residue_atoms);
      for (int i=0; i<n_residue_atoms; i++) {
	 std::string atom_name(residue_atoms[i]->name);
	 std::string atom_alt_conf(residue_atoms[i]->altLoc);

	 bool delete_this_atom_flag = 1; 
	 if (use_keep_atom_vector) {
	    for (unsigned int ikeep=0; ikeep<keep_atom_vector.size(); ikeep++) {
	       if (atom_name == keep_atom_vector[ikeep]) {
		  delete_this_atom_flag = 0;
		  break;
	       }
	    }
	 } else {
	    // i.e. is the this_residue, keep all of these atoms
	    delete_this_atom_flag = 0;
	 }
	 if (delete_this_atom_flag) { 
	    delete_atom_index_vec.push_back(i);
	 } else {
	    if ((atom_alt_conf != alt_conf) &&
		(atom_alt_conf != "")) {
	       delete_atom_index_vec.push_back(i);
	    }
	 }
      }

      if (delete_atom_index_vec.size() > 0) {
	 for (unsigned int i=0; i<delete_atom_index_vec.size(); i++)
	    residue_p->DeleteAtom(i);
	 residue_p->TrimAtomTable();
      }
   }
}



// As above, and also delete all atoms that are not C or O
void
coot::util::backrub_residue_triple_t::trim_prev_residue_atoms() {

   std::vector<std::string> vec;
   vec.push_back(" C  ");
   vec.push_back(" O  ");
   trim_residue_atoms_generic(this_residue, vec, 0);
}

   // As trim_this_residue_atoms, and also delete all atoms that are not N.
void
coot::util::backrub_residue_triple_t::trim_next_residue_atoms() {

   std::vector<std::string> vec;
   vec.push_back(" N  ");
   vec.push_back(" H  ");
   trim_residue_atoms_generic(this_residue, vec, 0);
}

// as in the verb, not the noun., return the number of segments (0 is
// also useful segment).
// 
std::pair<int, clipper::Xmap<int> >
coot::util::segment_map::segment_emsley_flood(const clipper::Xmap<float> &xmap, float low_level) {

   clipper::Xmap<int> xmap_int(xmap.spacegroup(),
			       xmap.cell(),
			       xmap.grid_sampling());

   int UNASSIGNED = -1;
   int TOO_LOW    = -2;

   // how many points are there in an xmap are there above the
   // (user-defined) noise level (low_level)?
   // 
   long n_points = 0;
   clipper::Xmap_base::Map_reference_index ix;
   for (ix = xmap.first(); !ix.last(); ix.next() )  {
      if (xmap[ix] < low_level) { 
	 xmap_int[ix] = TOO_LOW;
      } else { 
	 xmap_int[ix] = UNASSIGNED;
	 n_points++;
      }
   }

   std::vector<std::pair<clipper::Xmap_base::Map_reference_index, float> > density_values(n_points);
   long int i=0;
   for (ix = xmap.first(); !ix.last(); ix.next()) { 
      if (xmap[ix] >= low_level) { 
	 density_values[i] = std::pair<clipper::Xmap_base::Map_reference_index, float> (ix, xmap[ix]);
	 i++;
      }
   }

   std::sort(density_values.begin(), density_values.end(), compare_density_values_map_refs);

   int i_segment_index = 0;
   clipper::Coord_grid c_g;

   clipper::Skeleton_basic::Neighbours neighb(xmap, 0.5, 3.1); // 3x3x3 cube, not centre
   for (i=0; i<n_points; i++) {

      // Flood down points around xmap[density_values[i].first] (if
      // they are not already in the neigbourhood of a peak).
      //
      //
      if (xmap_int[density_values[i].first] == UNASSIGNED) {
	 
	 // OK, so this point starts a new segment
	 
	 int q_set = 0; // debugging counter
	 float v = xmap[density_values[i].first]; // all points in the segment should be
	                                          // lower than (or equal to) this density
	                                          // at the  "centre" of the segment blob.
	 xmap_int[density_values[i].first] = i_segment_index;
	 std::queue<clipper::Coord_grid> q;
	 for (int i_n=0; i_n<neighb.size(); i_n++) {
	    c_g = density_values[i].first.coord() + neighb[i_n];
	    if (xmap_int.get_data(c_g) == UNASSIGNED) {
	       if (xmap.get_data(c_g) <= v) {
		  xmap_int.set_data(c_g, i_segment_index);
		  q.push(c_g);
		  q_set++;
	       }
	    }
	 }

	 while (q.size()) {
	    clipper::Coord_grid c_g_start = q.front(); // new local centre
	    v = xmap.get_data(c_g_start);  
	    q.pop();
	    for (unsigned int i_n=0; i_n<neighb.size(); i_n++) {
	       c_g = c_g_start + neighb[i_n];
	       if (xmap_int.get_data(c_g) == UNASSIGNED) {
		  if (xmap.get_data(c_g) <= v) {

		     // But only set this neighbour if the steepest ascent from this
		     // neighbour is c_g. (otherwise we run into problems of crossing
		     // boundary at the border between segments when we take the steepest
		     // path up from them)

		     clipper::Coord_grid steepest_neighb(0,0,0);
		     float biggest = -1.0;
		     for (unsigned int i_nn=0; i_nn<neighb.size(); i_nn++) {
			float tv = xmap.get_data(c_g + neighb[i_nn]);
			if (tv > biggest) {
			   biggest = tv;
			   steepest_neighb = neighb[i_nn];
			}
		     }

		     if ((c_g + steepest_neighb) == c_g_start) { 
		  
			xmap_int.set_data(c_g, i_segment_index);
			q.push(c_g);
			q_set++;
		     }
		  } 
	       }
	    }
	 }
	 i_segment_index++;
      }
   }
   int n_segments = i_segment_index;
   return std::pair<int, clipper::Xmap<int> > (n_segments, xmap_int);
}



// as in the verb, not the noun., return the number of segments (0 is
// also useful segment).
// 
std::pair<int, clipper::Xmap<int> >
coot::util::segment_map::segment(const clipper::Xmap<float> &xmap, float low_level) {

   clipper::Xmap<int> xmap_int(xmap.spacegroup(),
			       xmap.cell(),
			       xmap.grid_sampling());

   int UNASSIGNED = -1;
   int TOO_LOW    = -2;

   // how many points are there in an xmap are there above the
   // (user-defined) noise level (low_level)?
   // 
   long n_points = 0;
   clipper::Xmap_base::Map_reference_index ix;
   for (ix = xmap.first(); !ix.last(); ix.next() )  {
      if (xmap[ix] < low_level) { 
	 xmap_int[ix] = TOO_LOW;
      } else { 
	 xmap_int[ix] = UNASSIGNED;
	 n_points++;
      }
   }

   std::vector<std::pair<clipper::Xmap_base::Map_reference_index, float> > density_values(n_points);
   long int i=0;
   for (ix = xmap.first(); !ix.last(); ix.next()) { 
      if (xmap[ix] >= low_level) { 
	 density_values[i] = std::pair<clipper::Xmap_base::Map_reference_index, float> (ix, xmap[ix]);
	 i++;
      }
   }

   std::sort(density_values.begin(), density_values.end(), compare_density_values_map_refs);

   int i_segment_index = 0;
   clipper::Coord_grid c_g;
   std::map<int, int> segment_id_counter_map;

   clipper::Skeleton_basic::Neighbours neighb(xmap, 0.5, 3.1); // 3x3x3 cube, not centre
   for (i=0; i<n_points; i++) {

      if (xmap_int[density_values[i].first] == UNASSIGNED) {
	 
	 float v = xmap[density_values[i].first];

	 // Does this grid point have a neighbour which is already in
	 // a segment?  If so, which one?  If there are many
	 // neighbours (this is a watershed point) then we need to make
	 // a note of all of them and choose later

	 std::map<int, std::vector<clipper::Coord_grid> > neighbour_count_map; // (as in the stl map)
	 for (int i_n=0; i_n<neighb.size(); i_n++) {
	    c_g = density_values[i].first.coord() + neighb[i_n];
	    int segment_index = xmap_int.get_data(c_g);
	    if (segment_index >= 0) {
	       neighbour_count_map[segment_index].push_back(c_g);
	    }
	 }

	 if (neighbour_count_map.size()) {

	    // OK, so add this grid point to a previously existing
	    // segment.  Now, which one?
	    // 
	    if (neighbour_count_map.size() == 1) {
	       xmap_int[density_values[i].first] = neighbour_count_map.begin()->first;
	       segment_id_counter_map[neighbour_count_map.begin()->first]++;
	    } else {

	       // The complicated case, we have to decide which is the
	       // biggest of the neighbouring segments and add this
	       // grid point to that segment.

	       // int big_seg_id = find_biggest_segment(neighbour_count_map, segment_id_counter_map);
	       int big_seg_id = find_smallest_segment(neighbour_count_map, segment_id_counter_map);
	       if (0) 
		  std::cout << "watershed point " << density_values[i].first.coord().format()
			    << " has " << neighbour_count_map.size() << " neighboring segments and "
			    << " is of segment " << big_seg_id << "\n";
	       xmap_int[density_values[i].first] = big_seg_id;
	       segment_id_counter_map[big_seg_id]++;
	       
	    } 

	 } else { 

	    // this didn't have any neighbours so we start a new segment:
	    // 
	    xmap_int[density_values[i].first] = i_segment_index;
	    segment_id_counter_map[i_segment_index]++;
	    i_segment_index++; // for next round
	 }
      }
   }
   resegment_watershed_points(&xmap_int, xmap); // Pintilie et al. didn't mention that we need this.

   int n_segments = i_segment_index;
   return std::pair<int, clipper::Xmap<int> > (n_segments, xmap_int);
}



// sorting function used by segmentation
//
// static
bool
coot::util::segment_map::compare_density_values_map_refs(const std::pair<clipper::Xmap_base::Map_reference_index, float> &v1,
					    const std::pair<clipper::Xmap_base::Map_reference_index, float> &v2) {
   return (v2.second < v1.second);
}

// Pintilie et al. didn't mention that we need this.
void 
coot::util::segment_map::resegment_watershed_points(clipper::Xmap<int> *xmap_int_in,
						    const clipper::Xmap<float> &xmap) const {

   clipper::Xmap<int> &xmap_int = *xmap_int_in;
   clipper::Skeleton_basic::Neighbours neighb(xmap, 0.5, 3.1); // 3x3x3 cube, not centre
   
   clipper::Xmap_base::Map_reference_index ix;
   int is;
   int ns;
   clipper::Coord_grid c_g;

   for (ix = xmap_int.first(); !ix.last(); ix.next()) {
      is = xmap_int[ix];
      if (is >= 0) {
	 std::map<int, int> segment_id_map;
	 for (unsigned int i_n=0; i_n<neighb.size(); i_n++) {
	    c_g = ix.coord() + neighb[i_n];
	    ns = xmap_int.get_data(c_g);
	    if (ns >= 0) 
	       segment_id_map[ns]++;
	 }
	 if (segment_id_map.size() > 1) {
	    // OK, we have a watershed point, we need to (potentially) change the segment to the
	    // one which has the steepest gradient from this point.
	    float v = xmap[ix];
	    float vn;
	    float best_vn = -1;
	    clipper::Coord_grid best_n;
	    for (unsigned int i_n=0; i_n<neighb.size(); i_n++) {
	       c_g = ix.coord() + neighb[i_n];
	       vn = xmap.get_data(c_g);
	       if (v > best_vn) { 
		  if (vn > v) {
		     best_vn = vn;
		     best_n = neighb[i_n];
		  }
	       }
	    }
	    // OK, best_vn was set
	    if (best_vn > -0.9) {
	       int i_seg_neighb = xmap_int.get_data(ix.coord() + best_n);
	       if (xmap_int[ix] != i_seg_neighb) {
		  if (0)
		     std::cout << "Resegmenting " << ix.coord().format() << " from " << xmap_int[ix] << " to "
			       << i_seg_neighb << "\n";
		  xmap_int[ix] = i_seg_neighb;
	       }
	    } 
	 }
      }
   }

} 


// "scale-space" segmentation (i.e. merge segments by progressive blurring)
// 
std::pair<int, clipper::Xmap<int> >
coot::util::segment_map::segment(const clipper::Xmap<float> &xmap_in,
				 float low_level,
				 float gaussian_sigma, // per round
				 int n_rounds) {

   // This algorithm is critically dependent on the gradient around
   // points on the borders between segments (the watershed regions).
   // 
   // If we 
   // 
   // 1) segment then input map
   //
   // 2) do a high-res fft of map, then re-fft to get a new map and
   //    then segment that
   //
   // then the segmentation is very different.
   //
   // Well, so be it.
   //
   // So, the first map that we segment should use exactly the same
   // sfs throughout, the only difference being a blurring gaussian
   // function which scales the f values.
   //
   // the f and phis for the map are fphis.  Each round they get
   // manipulated and they are fphis_for_loop, a local copy
   // 

   int n_segments = 0;


   clipper::Xmap<std::pair<bool, int> > segmented;
   segmented.init(xmap_in.spacegroup(),
		  xmap_in.cell(),
		  xmap_in.grid_sampling());
   clipper::Xmap_base::Map_reference_index ix;

   float mg = coot::util::max_gridding(xmap_in);
   // std::cout << "We got max gridding " << mg << std::endl;
   clipper::Resolution reso(mg); // nice high res.
   clipper::HKL_info myhkl(xmap_in.spacegroup(), xmap_in.cell(), reso, true); 
   clipper::HKL_data< clipper::datatypes::F_phi<float> >       fphis(myhkl);
   clipper::Xmap<float> xmap_first(xmap_in.spacegroup(), xmap_in.cell(), xmap_in.grid_sampling());
   xmap_in.fft_to(fphis);
   xmap_first.fft_from(fphis);
   std::pair<int, clipper::Xmap<int> > segmented_first = segment(xmap_first, low_level);
   for (ix = segmented_first.second.first(); !ix.last(); ix.next())
      segmented[ix] = std::pair<bool, int> (0 , segmented_first.second[ix]);

   // debugging
   std::cout << " ===================== initial segmentation: ===================\n";
   std::map<int, int> debug_segment_id_map;
   for (ix=segmented.first(); !ix.last(); ix.next()) {
      debug_segment_id_map[segmented[ix].second]++;
   }
   std::map<int, int>::const_iterator dit;
   for (dit=debug_segment_id_map.begin(); dit!=debug_segment_id_map.end(); dit++)
      std::cout << "  segment " << dit->first << " has " << dit->second << " grid points" << std::endl;
   std::cout << " ========================================\n";

   
   
   for (int i_round=0; i_round<n_rounds; i_round++) {

      std::cout << "INFO Segmentation: Round " << i_round << " of " << n_rounds << std::endl;

      // float round_factor = 1.0/float(i_round + 1);
      float round_factor = (i_round + 1);
      clipper::HKL_data< clipper::datatypes::F_phi<float> >  fphis_for_loop = fphis;

      clipper::HKL_info::HKL_reference_index hri;
      for (hri = fphis_for_loop.first(); !hri.last(); hri.next()) {
	 if (! clipper::Util::is_nan(fphis_for_loop[hri].f())) {
	    float irs =  hri.invresolsq();
	    float scale = expf(- round_factor * irs * irs/(2 * gaussian_sigma * gaussian_sigma));
	    scale = 1;
	    fphis_for_loop[hri].f() *= scale;
	    if (0) 
	       std::cout << " new f: " << hri.hkl().format() << " " <<  fphis_for_loop[hri].f()
			 << " reso= " << irs
			 << "   and scale " << scale << "\n";
	 }
      }

      clipper::Xmap<float> xmap_new(xmap_in.spacegroup(),
				    xmap_in.cell(),
				    xmap_in.grid_sampling());
   
      xmap_new.fft_from(fphis_for_loop);
   
      for (ix = xmap_new.first(); !ix.last(); ix.next()) {
	 if (segmented[ix].second != TOO_LOW) {

	    // assert
	    if (segmented[ix].second == UNASSIGNED)
	       std::cout << "  segmentation failure, UNASSIGNED value"
			 << ix.coord().format() << std::endl;

	    // path includes the starting point ix.coord();
	    std::vector<clipper::Coord_grid> path = path_to_peak(ix.coord(), xmap_new);
	    if (path.size() > 1) {
	       int segmented_start = segmented[ix].second;
	       int segmented_local_peak = segmented.get_data(path.back()).second;

	       if (segmented_local_peak != segmented_start) {

		  if (0) {
		     std::cout << " ============= yeay! map point "
			       << ix.coord().format() << " " << segmented_start
			       << " with path\n";
		     for (unsigned int i=0; i<path.size(); i++) { 
			std::cout << "    " << path[i].format() << " segment: "
				  << segmented.get_data(path[i]).second << " value: "
				  << xmap_new.get_data(path[i])
				  << std::endl;
		     }
		     std::cout << " ending in segment: " << segmented_local_peak
			       << std::endl;
		  }
	       
		  for (unsigned int ipath=0; ipath<path.size(); ipath++) {
		     if (segmented.get_data(path[ipath]).second != segmented_local_peak) 
			flood_fill_segmented_map(&segmented, xmap_in, path[ipath],
						 segmented_start, segmented_local_peak);
		  }
	       }
	    } 
	 } 
      }
   }

   clipper::Xmap<int> clean_segmented;
   clean_segmented.init(segmented.spacegroup(),
			segmented.cell(),
			segmented.grid_sampling());
   clean_segmented = UNASSIGNED;
   std::map<int, int> segment_id_map; // as in the STL map, not clipper map

   // We want to eliminate gaps in the segmentation number: i.e. first
   // segment should be 0 and increment from there.
   std::map<int, int> segment_id_reindexer; // from -> to

   int seg_id;
   int new_index;
   std::map<int, int>::const_iterator it;
   int segment_counter = 0;
   
   for (ix=segmented.first(); !ix.last(); ix.next()) {
      seg_id = segmented[ix].second;
      if (seg_id == TOO_LOW) {
	 clean_segmented[ix] = TOO_LOW;
      } else { 
	 if (seg_id == UNASSIGNED) {
	    clean_segmented[ix] = UNASSIGNED;
	 } else { 
	    
	    it = segment_id_reindexer.find(seg_id);
	    if (it != segment_id_reindexer.end()) {
	       // it was found
	       new_index = it->second;
	    } else {
	       segment_id_reindexer[seg_id] = segment_counter;
	       new_index = segment_counter;
	       segment_counter++;
	    }
	    clean_segmented[ix] = new_index;
	 }
      }
   }
   n_segments = segment_counter+1;

   // Now we want to renumber the segments so that the segments with
   // the most points have the lowest segment numbers.
   
   for (ix=clean_segmented.first(); !ix.last(); ix.next())
      segment_id_map[clean_segmented[ix]]++;

   if (0) { 
      std::cout << "======= pre-sort segments analysis =========" << std::endl;
      for (it=segment_id_map.begin(); it!=segment_id_map.end(); it++)
	 std::cout << "  segment " << it->first << " has " << it->second << " grid points" << std::endl;
      std::cout << "===================================" << std::endl;
   }

   // create a vector for sorting.
   std::vector<std::pair<int, int> > segment_vec(segment_id_map.size());
   for (int icount=0; icount<segment_vec.size(); icount++) {
      segment_vec[icount] = std::pair<int, int> (segment_id_map[icount], icount);
   }
   std::sort(segment_vec.begin(), segment_vec.end(), sort_segment_vec);
   
   for (unsigned int i=0; i<segment_vec.size(); i++) { 
      std::cout << "segment index:" << i << " with " << segment_vec[i].first << " grid points and "
		<< "old index " << segment_vec[i].second << std::endl;
   }
   std::cout << "===================================" << std::endl;

   // create a map, fill it from the above sorted vector and give it
   // the sorted segment index.
   
   std::map<int, int> new_index_map;
   for (unsigned int i=0; i<segment_vec.size(); i++)
      new_index_map[segment_vec[i].second] = i;
   
   for (ix=clean_segmented.first(); !ix.last(); ix.next())
      if (clean_segmented[ix] != UNASSIGNED)
	 if (clean_segmented[ix] != TOO_LOW)
	    clean_segmented[ix] = new_index_map[clean_segmented[ix]];

   // ------------------------ post sort analysis -------------------------
   
   segment_id_map.clear();
   for (ix=clean_segmented.first(); !ix.last(); ix.next())
      segment_id_map[clean_segmented[ix]]++;

   std::cout << "======= post-sort segments analysis =========" << std::endl;
   for (it=segment_id_map.begin(); it!=segment_id_map.end(); it++)
      std::cout << "  " << it->first << " has " << it->second << " grid points" << std::endl;
   std::cout << "===================================" << std::endl;
   
   return std::pair<int, clipper::Xmap<int> > (n_segments, clean_segmented);

   
}


int
coot::util::segment_map::find_biggest_segment(const std::map<int, std::vector<clipper::Coord_grid> > &segment_id_map, const std::map<int, int> &segment_id_counter_map) const {

   // look through all of the segments in the segment id map and 
   
   int seg_id_biggest = UNASSIGNED;
   int n_gp_in_biggest_segment = 0;
   std::map<int, std::vector<clipper::Coord_grid> >::const_iterator it;
   for (it=segment_id_map.begin(); it!=segment_id_map.end(); it++) {
      std::map<int, int>::const_iterator iti = segment_id_counter_map.find(it->first);
      if (iti != segment_id_counter_map.end()) { 
	 if (iti->second > n_gp_in_biggest_segment) {
	    n_gp_in_biggest_segment = iti->second;
	    seg_id_biggest = it->first;
	 }
      }
   }

   return seg_id_biggest;
}

int
coot::util::segment_map::find_smallest_segment(const std::map<int, std::vector<clipper::Coord_grid> > &segment_id_map, const std::map<int, int> &segment_id_counter_map) const {

   // look through all of the segments in the segment id map and 
   
   int seg_id_smallest = UNASSIGNED;
   int n_gp_in_smallest_segment = 65500;
   std::map<int, std::vector<clipper::Coord_grid> >::const_iterator it;
   for (it=segment_id_map.begin(); it!=segment_id_map.end(); it++) {
      std::map<int, int>::const_iterator iti = segment_id_counter_map.find(it->first);
      if (iti != segment_id_counter_map.end()) { 
	 if (iti->second < n_gp_in_smallest_segment) {
	    n_gp_in_smallest_segment = iti->second;
	    seg_id_smallest = it->first;
	 }
      }
   }

   return seg_id_smallest;
}


// static
bool
coot::util::segment_map::sort_segment_vec(const std::pair<int, int> &a,
					  const std::pair<int, int> &b) {
   return (b.first < a.first);
} 


// change values in segmented_map
// 
void
coot::util::segment_map::flood_fill_segmented_map(clipper::Xmap<std::pair<bool, int> > *segmented_map,
						  const clipper::Xmap<float> &xmap,
						  const clipper::Coord_grid &seed_point,
						  int from_val, int to_val) {

   clipper::Skeleton_basic::Neighbours neighb(xmap, 0.5, 3.1); // 3x3x3 cube, not centre
   std::queue<clipper::Coord_grid> q;
   clipper::Coord_grid c_g;

   q.push(seed_point);
   int n_converted = 0;
   
   while (q.size()) {
      clipper::Coord_grid c_g_start = q.front(); // new local centre
      q.pop();
      for (unsigned int i_n=0; i_n<neighb.size(); i_n++) {
	 c_g = c_g_start + neighb[i_n];
	 if (segmented_map->get_data(c_g).second == from_val) {
	    segmented_map->set_data(c_g, std::pair<bool,int> (1, to_val));
	    if (0) 
	       std::cout << " converted " << c_g.format() << " from "
			 << from_val << " to " << to_val << std::endl;
	    n_converted++; //debugging
	    q.push(c_g);
	 }
      }
   }

   if (0)
      std::cout << "=== flood_fill_segmented_map: converted "
		<< n_converted << " grid points from " << from_val
		<< " to " << to_val << std::endl;
   
   // debugging
   if (n_converted == 0) {
      std::cout << "diagnose 0 conversions: " << seed_point.format() << " "
		<< segmented_map->get_data(seed_point).second << " with neighbours: " << std::endl;
      for (unsigned int i_n=0; i_n<neighb.size(); i_n++) {
	 std::cout << "diagnose 0 conversions:    "
		   << i_n << " " << neighb[i_n].format() << " "
		   << segmented_map->get_data(seed_point + neighb[i_n]).second
		   << std::endl;
      }
   }

}

// Return a vector grid points as we trace the route to the
// local peak from start_point.
// 
std::vector<clipper::Coord_grid>
coot::util::segment_map::path_to_peak(const clipper::Coord_grid &start_point,
				      const clipper::Xmap<float> &xmap) {

   std::vector<clipper::Coord_grid> v;
   clipper::Skeleton_basic::Neighbours neighb(xmap, 0.5, 3.1); // 3x3x3 cube, not centre

   clipper::Coord_grid current_point = start_point;
   v.push_back(start_point);
   bool at_peak = 0;
   
   while (! at_peak) {
      float current_val = xmap.get_data(current_point);

      // what is the biggest value of the neighbours greater than current_value?
      //
      bool found_bigger = 0;
      clipper::Coord_grid biggest_neighbour;
      float biggest = -1;
      for (unsigned int i_n=0; i_n<neighb.size(); i_n++) {
	 float v = xmap.get_data(current_point + neighb[i_n]);
	 if (0) 
	    std::cout << "current: " << current_point.format() << " " << current_val
		      << "    neighb " << i_n << " " << neighb[i_n].format() << " "
		      << v << " and biggest " << biggest << std::endl;
	 if (v > biggest) {
	    if (v > current_val) { 
	       found_bigger = 1;
	       biggest = v;
	       biggest_neighbour = neighb[i_n];
	    }
	 } 
      }

      if (! found_bigger) {
	 at_peak = 1;
      } else {
	 current_point += biggest_neighbour;
	 v.push_back(current_point);
      } 
      
   }
   return v;
} 


#include <clipper/contrib/edcalc.h>

#include "coords/mmdb-extras.h"
#include "coords/mmdb.h"

// pass a negative atom_selection_handle to build an atom map for the whole molecule
// 
clipper::Xmap<float>
coot::util::calc_atom_map(CMMDBManager *mol,
			  int atom_selection_handle,
			  const clipper::Cell &cell,
			  const clipper::Spacegroup &space_group,
			  const clipper::Grid_sampling &sampling) {

   clipper::Xmap<float> xmap;
   xmap.init(space_group, cell, sampling);

   std::vector<clipper::Atom> l;

   PPCAtom sel_atoms = 0;
   int n_atoms;
   mol->GetSelIndex(atom_selection_handle, sel_atoms, n_atoms);


   // 20130710 for some reason this gives (memory?) errors when making clipper::Atom atom
   // (coords are nan and ele is scrambled text)
   // 
//    for (unsigned int i=0; i<n_atoms; i++) {
//       CAtom mmdb_atom;
//       mmdb_atom.Copy(sel_atoms[i]);
//       clipper::MMDBAtom clipper_mmdb_at(mmdb_atom);
//       clipper::Atom atom(clipper_mmdb_at);
//       std::cout << "copied mmdb_atom " << clipper_mmdb_at << " to clipper atom "
// 		<< atom.coord_orth().format() << " " << atom.element()
// 		<< std::endl;
//       l.push_back(atom);
//    }

   for (unsigned int iat=0; iat<n_atoms; iat++) {
      CAtom *at = sel_atoms[iat];
      clipper::Coord_orth pt(at->x, at->y, at->z);
      std::string ele(at->element);
      clipper::Atom cat;
      cat.set_element(ele);
      cat.set_coord_orth(pt);
      cat.set_u_iso(at->tempFactor);
      cat.set_occupancy(at->occupancy);
      l.push_back(cat);
   }

   try {

      clipper::Atom_list al(l);
      if (0) { // debug
	 std::cout << "======================= al size(): " << al.size() << std::endl;
	 std::cout << "here are some atoms" << std::endl;
	 for (unsigned int iat=0; iat<5; iat++)
	    std::cout << "           "
		      << al[iat].coord_orth().format() << " "
		      << al[iat].element() << std::endl;
      }
      clipper::EDcalc_iso<float> e;
      e(xmap, al);
   }
   catch (clipper::Message_generic &e) {
      std::cout << "ERROR:: some sort of clipper map problem" << std::endl;
      std::cout << e.text() << std::endl;
   }
   return xmap;
}

#include "clipper/ccp4/ccp4_map_io.h"

// 0: all-atoms
// 1: main-chain atoms if is standard amino-acid, else all atoms
// 2: side-chain atoms if is standard amino-acid, else all atoms
// 3: side-chain atoms-exclusing CB if is standard amino-acid, else all atoms
// 4: main-chain atoms if is standard amino-acid, else nothing
// 5: side-chain atoms if is standard amino-acid, else nothing
// 
float
coot::util::map_to_model_correlation(CMMDBManager *mol,
				     const std::vector<residue_spec_t> &specs,
				     unsigned short int atom_mask_mode,
				     float atom_radius,
				     const clipper::Xmap<float> &reference_map) {

   float ret_val = -2;
   int SelHnd = mol->NewSelection(); // d

   // std::cout << "There are " << specs.size() << " residues " << std::endl;
   // for (unsigned int ilocal=0; ilocal<specs.size(); ilocal++)
   // std::cout << "   " << specs[ilocal] << std::endl;

   for (unsigned int ilocal=0; ilocal<specs.size(); ilocal++) {
      
      std::string res_name_selection  = "*";
      std::string atom_name_selection = "*";

      if (atom_mask_mode != 0) { // main chain for standard amino acids
	 CResidue *res = get_residue(specs[ilocal], mol);
	 if (res) {
	    std::string residue_name(res->GetResName());
	    if (is_standard_residue_name(residue_name)) { 

	       // PDBv3 FIXME
	       // 
	       if (atom_mask_mode == 1)
		  atom_name_selection = " N  , H  , HA , CA , C  , O  ";
	       if (atom_mask_mode == 2)
		  atom_name_selection = "!( N  , H  , HA , CA , C  , O  )";
	       if (atom_mask_mode == 3)
		  atom_name_selection = "!( N  , H  , HA , CA , C  , O  , CB )";
	    } else {
	       if (atom_mask_mode == 4)
		  atom_name_selection = "%%%%%%"; // nothing (perhaps use "")
	       if (atom_mask_mode == 5)
		  atom_name_selection = "%%%%%%"; // nothing
	    }
	 }
      }
      
      mol->SelectAtoms(SelHnd, 1,
		       specs[ilocal].chain.c_str(),
		       specs[ilocal].resno,
		       specs[ilocal].insertion_code.c_str(),
		       specs[ilocal].resno,
		       specs[ilocal].insertion_code.c_str(),
		       res_name_selection.c_str(),
		       atom_name_selection.c_str(), 
		       "*", // elements
		       "*", // alt loc.
		       SKEY_OR
		       );
   }

   clipper::Xmap<float> calc_map =
      coot::util::calc_atom_map(mol, SelHnd,
				reference_map.cell(),
				reference_map.spacegroup(),
				reference_map.grid_sampling());

   if (not (calc_map.is_null())) { 
      clipper::Xmap<short int> masked_map(reference_map.spacegroup(),
					  reference_map.cell(),
					  reference_map.grid_sampling());
      clipper::Xmap_base::Map_reference_index ix;
      for (ix = masked_map.first(); !ix.last(); ix.next())
	 masked_map[ix] = 0;
      PPCAtom atom_selection = 0;
      int n_atoms;
      mol->GetSelIndex(SelHnd, atom_selection, n_atoms);

      // debugging atom selection
      if (0) { 
	 std::cout << "debug:: selected " << n_atoms << " atoms " << std::endl;
	 for (unsigned int iat=0; iat<n_atoms; iat++)
	    std::cout << "    " << iat << " " << atom_selection[iat]->name << " "
		      << atom_selection[iat] << std::endl;
      }
      
      for (unsigned int iat=0; iat<n_atoms; iat++) {
	 clipper::Coord_orth co(atom_selection[iat]->x,
				atom_selection[iat]->y,
				atom_selection[iat]->z);
	 clipper::Coord_frac cf = co.coord_frac(masked_map.cell());
	 clipper::Coord_frac box0(
				  cf.u() - atom_radius/masked_map.cell().descr().a(),
				  cf.v() - atom_radius/masked_map.cell().descr().b(),
				  cf.w() - atom_radius/masked_map.cell().descr().c());

	 clipper::Coord_frac box1(
				  cf.u() + atom_radius/masked_map.cell().descr().a(),
				  cf.v() + atom_radius/masked_map.cell().descr().b(),
				  cf.w() + atom_radius/masked_map.cell().descr().c());

	 clipper::Grid_map grid(box0.coord_grid(masked_map.grid_sampling()),
				box1.coord_grid(masked_map.grid_sampling()));

	 float atom_radius_sq = atom_radius * atom_radius;

	 clipper::Xmap_base::Map_reference_coord ix(masked_map, grid.min() ), iu, iv, iw;
	 for ( iu = ix; iu.coord().u() <= grid.max().u(); iu.next_u() ) { 
	    for ( iv = iu; iv.coord().v() <= grid.max().v(); iv.next_v() ) { 
	       for ( iw = iv; iw.coord().w() <= grid.max().w(); iw.next_w() ) {
		  if ( (iw.coord().coord_frac(masked_map.grid_sampling()).coord_orth(masked_map.cell()) - co).lengthsq() < atom_radius_sq) {
		     if (0)
			std::cout << "masked point at " 
				  << iw.coord().coord_frac(masked_map.grid_sampling()).coord_orth(masked_map.cell()).format()
				  << " centre point: " << co.format() << " " 
				  << (iw.coord().coord_frac(masked_map.grid_sampling()).coord_orth(masked_map.cell()) - co).lengthsq() 
				  << std::endl;
		     masked_map[iw] = 1;
		  }
	       }
	    }
	 }
      }

      double sum_x  = 0;
      double sum_y  = 0;
      double sum_x_sqd  = 0;
      double sum_y_sqd  = 0;
      double sum_xy = 0;
      int n = 0;
      for (ix = reference_map.first(); !ix.last(); ix.next()) {
	 double x = calc_map[ix];
	 if (! clipper::Util::is_nan(x)) { 
	    double y = reference_map[ix];
	    if (! clipper::Util::is_nan(y)) { 
	       if (masked_map[ix]) {
		  sum_x  += x;
		  sum_y  += y;
		  sum_xy += x * y;
		  sum_x_sqd += x*x;
		  sum_y_sqd += y*y;
		  n++;
	       }
	    } else {
	       std::cout << "ERROR:: oops (reference) map density for " << ix.coord().format()
			 << " is nan " << std::endl;
	    } 
	 } else {
	    std::cout << "ERROR:: oops calc density for " << ix.coord().format() << " is nan "
		      << std::endl;
	 }
      }


      if (0) { 
	 // just checking that the maps are what we expect them to be...
	 clipper::CCP4MAPfile mapout;
	 mapout.open_write("calc.map");
	 mapout.export_xmap(calc_map);
	 mapout.close_write();
	 
	 clipper::CCP4MAPfile mapout_mask;
	 mapout_mask.open_write("masked.map");
	 mapout_mask.export_xmap(masked_map);
	 mapout_mask.close_write();
      }

      double top = double(n) * sum_xy - sum_x * sum_y;
      double b_1 = double(n) * sum_x_sqd - sum_x * sum_x;
      double b_2 = double(n) * sum_y_sqd - sum_y * sum_y;
      if (0) { 
	 std::cout << ".... n is " << n << std::endl;
	 std::cout << ".... sum_xy is " << sum_xy << std::endl;
	 std::cout << ".... sum_x is " << sum_x << std::endl;
	 std::cout << ".... sum_y is " << sum_y << std::endl;
	 std::cout << ".... top is " << top << std::endl;
	 std::cout << ".... b_1 is " << b_1 << std::endl;
	 std::cout << ".... b_2 is " << b_2 << std::endl;
      }

      if (b_1 < 0) b_1 = 0;
      if (b_2 < 0) b_2 = 0;

      double c = top/(sqrt(b_1) * sqrt(b_2));
      if (0)
	 std::cout << "INFO:: map vs model correlation: " << c << std::endl;
      ret_val = c;
   }
   mol->DeleteSelection(SelHnd);
   return ret_val;
}

// the first of the pair contains the correlation for the given residue spec.
// 
std::vector<std::pair<coot::residue_spec_t, float> >
coot::util::map_to_model_correlation_per_residue(CMMDBManager *mol,
						 const std::vector<coot::residue_spec_t> &specs,
						 unsigned short int atom_mask_mode,
						 float atom_radius, // for masking 
						 const clipper::Xmap<float> &reference_map) {

   std::vector<std::pair<residue_spec_t, float> > v;
   int SelHnd = mol->NewSelection(); // d

   for (unsigned int ispec=0; ispec<specs.size(); ispec++) {
      
      std::string res_name_selection  = "*";
      std::string atom_name_selection = "*";

      if (atom_mask_mode != 0) { // main chain for standard amino acids
	 CResidue *res = get_residue(specs[ispec], mol);
	 if (res) {
	    std::string residue_name(res->GetResName());
	    if (is_standard_residue_name(residue_name)) { 

	       // PDBv3 FIXME
	       // 
	       if (atom_mask_mode == 1)
		  atom_name_selection = " N  , H  , HA , CA , C  , O  ";
	       if (atom_mask_mode == 2)
		  atom_name_selection = "!( N  , H  , HA , CA , C  , O  )";
	       if (atom_mask_mode == 3)
		  atom_name_selection = "!( N  , H  , HA , CA , C  , O  , CB )";
	    } else {
	       if (atom_mask_mode == 4)
		  atom_name_selection = "%%%%%%"; // nothing (perhaps use "")
	       if (atom_mask_mode == 5)
		  atom_name_selection = "%%%%%%"; // nothing
	    }
	 }
      }
      
      mol->SelectAtoms(SelHnd, 1,
		       specs[ispec].chain.c_str(),
		       specs[ispec].resno,
		       specs[ispec].insertion_code.c_str(),
		       specs[ispec].resno,
		       specs[ispec].insertion_code.c_str(),
		       res_name_selection.c_str(),
		       atom_name_selection.c_str(), 
		       "*", // elements
		       "*", // alt loc.
		       SKEY_OR
		       );
   }


   clipper::Xmap<float> calc_map =
      coot::util::calc_atom_map(mol, SelHnd,
				reference_map.cell(),
				reference_map.spacegroup(),
				reference_map.grid_sampling());
   
   if (not (calc_map.is_null())) {
      // fill with null residue specs
      clipper::Xmap<residue_spec_t> contributor_map(reference_map.spacegroup(),
						    reference_map.cell(),
						    reference_map.grid_sampling());
      clipper::Xmap_base::Map_reference_index ix;
      PPCAtom atom_selection = 0;
      int n_atoms;
      mol->GetSelIndex(SelHnd, atom_selection, n_atoms);

      residue_spec_t many_contributors; // we don't want map that is contributed to by
                                        // many (2 or more) residues.
      int MANY_CONTRIBUTORS = 200; // magic value
      many_contributors.int_user_data = MANY_CONTRIBUTORS; 


      for (unsigned int iat=0; iat<n_atoms; iat++) {
	 residue_spec_t res_spec(atom_selection[iat]);
	 clipper::Coord_orth co(atom_selection[iat]->x,
				atom_selection[iat]->y,
				atom_selection[iat]->z);
	 clipper::Coord_frac cf = co.coord_frac(reference_map.cell());
	 clipper::Coord_frac box0(
				  cf.u() - atom_radius/reference_map.cell().descr().a(),
				  cf.v() - atom_radius/reference_map.cell().descr().b(),
				  cf.w() - atom_radius/reference_map.cell().descr().c());

	 clipper::Coord_frac box1(
				  cf.u() + atom_radius/reference_map.cell().descr().a(),
				  cf.v() + atom_radius/reference_map.cell().descr().b(),
				  cf.w() + atom_radius/reference_map.cell().descr().c());

	 clipper::Grid_map grid(box0.coord_grid(reference_map.grid_sampling()),
				box1.coord_grid(reference_map.grid_sampling()));

	 float atom_radius_sq = atom_radius * atom_radius;
	 clipper::Xmap_base::Map_reference_coord ix(reference_map, grid.min() ), iu, iv, iw;
	 for ( iu = ix; iu.coord().u() <= grid.max().u(); iu.next_u() ) { 
	    for ( iv = iu; iv.coord().v() <= grid.max().v(); iv.next_v() ) { 
	       for ( iw = iv; iw.coord().w() <= grid.max().w(); iw.next_w() ) {
		  if ( (iw.coord().coord_frac(reference_map.grid_sampling()).coord_orth(reference_map.cell()) - co).lengthsq() < atom_radius_sq) {
		     if (0)
			std::cout << "specs: masked point at " 
// 				  << iw.coord().coord_frac(reference_map.grid_sampling()).coord_orth(reference_map.cell()).format()
// 				  << " centre point: " << co.format() << " " 
// 				  << (iw.coord().coord_frac(reference_map.grid_sampling()).coord_orth(reference_map.cell()) - co).lengthsq()
				  << iw.coord().format() 
				  << std::endl;
		     if (contributor_map[iw].int_user_data != MANY_CONTRIBUTORS) {
			// so it was either set once or not at all (so far).
			if (contributor_map[iw].unset_p()) {
			   // was a default residue spec (an as-yet untouched grid point).
			   contributor_map[iw] = res_spec;
			} else {
			   if (contributor_map[iw] == res_spec) {
			      // OK, cool we are in the same residue
			   } else {
			      // Oops. A bang.  Mask this point out
			      // std::cout << "   4 a bang for grid point " << iw.coord().format() << " "
			      // << contributor_map[iw] << " vs " << res_spec << std::endl;
			      contributor_map[iw] = many_contributors;
			   }
			}
		     } else {
			// std::cout << iw.coord().format() << " was already a many_contributor" << std::endl;
		     }
		  }
	       }
	    }
	 }
      }

      std::map<residue_spec_t, map_stats_holder_helper_t> map_stats;
      for (ix = contributor_map.first(); !ix.last(); ix.next()) {
	 if (! contributor_map[ix].unset_p()) {
	    if (contributor_map[ix].int_user_data != MANY_CONTRIBUTORS) {
	       map_stats[contributor_map[ix]].add_xy(calc_map[ix], reference_map[ix]);
	    }
	 }
      }

      std::map<residue_spec_t, map_stats_holder_helper_t>::const_iterator it;
      for (it=map_stats.begin(); it!=map_stats.end(); it++) {

	 if (0)
	    std::cout << "   " << it->first << " n: " << it->second.n << " spec user-data: "
		      << it->first.int_user_data << std::endl;
	 
	 if (it->second.n > 1) {
	    double top = double(it->second.n) * it->second.sum_xy        - it->second.sum_x * it->second.sum_y;
	    double b_1 = double(it->second.n) * it->second.sum_x_squared - it->second.sum_x * it->second.sum_x;
	    double b_2 = double(it->second.n) * it->second.sum_y_squared - it->second.sum_y * it->second.sum_y;
	    if (b_1 < 0) b_1 = 0;
	    if (b_2 < 0) b_2 = 0;
	    double c = top/(sqrt(b_1) * sqrt(b_2));
	    std::pair<residue_spec_t, float> p(it->first, c);
	    v.push_back(p);
	 } 
      } 
   }
   mol->DeleteSelection(SelHnd);
   return v;
}



std::vector<float>
coot::util::density_map_points_in_sphere(clipper::Coord_orth pt, float search_radius, const clipper::Xmap<float> &xmap) {

   std::vector<float> v;

   float search_radius_sq = search_radius * search_radius; 
   clipper::Coord_frac cf = pt.coord_frac(xmap.cell());
   clipper::Coord_frac box0(cf.u() - search_radius/xmap.cell().descr().a(),
			    cf.v() - search_radius/xmap.cell().descr().b(),
			    cf.w() - search_radius/xmap.cell().descr().c());

   clipper::Coord_frac box1(cf.u() + search_radius/xmap.cell().descr().a(),
			    cf.v() + search_radius/xmap.cell().descr().b(),
			    cf.w() + search_radius/xmap.cell().descr().c());

   clipper::Grid_map grid(box0.coord_grid(xmap.grid_sampling()),
			  box1.coord_grid(xmap.grid_sampling()));

   clipper::Xmap_base::Map_reference_coord ix(xmap, grid.min()), iu, iv, iw;
   for ( iu = ix; iu.coord().u() <= grid.max().u(); iu.next_u() ) {
      for ( iv = iu; iv.coord().v() <= grid.max().v(); iv.next_v() ) { 
	 for ( iw = iv; iw.coord().w() <= grid.max().w(); iw.next_w() ) {
	    // sample a sphere
	    if ( (iw.coord().coord_frac(xmap.grid_sampling()).coord_orth(xmap.cell()) - pt).lengthsq() < search_radius_sq) {
	       v.push_back(xmap[iw]);
	    }
	 }
      }
   }
   return v;
}

